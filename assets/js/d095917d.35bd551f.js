"use strict";(self.webpackChunkdeploy_to_vm=self.webpackChunkdeploy_to_vm||[]).push([[5150],{7811:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"Repositories/PRISM/FastAPI/Helper Functions/find_conflicting_paths","title":"find_conflicting_paths_np","description":"This function analyzes multiple drone paths (each represented as a NumPy array of positions and times) to find drones that come within a minimum safe distance of each other at the same or near time steps, indicating potential conflicts or collisions.","source":"@site/docs/Repositories/PRISM/FastAPI/Helper Functions/find_conflicting_paths.md","sourceDirName":"Repositories/PRISM/FastAPI/Helper Functions","slug":"/Repositories/PRISM/FastAPI/Helper Functions/find_conflicting_paths","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/find_conflicting_paths","draft":false,"unlisted":false,"editUrl":"https://github.com/ryyanrashid01/devdocs/edit/main/docs/Repositories/PRISM/FastAPI/Helper Functions/find_conflicting_paths.md","tags":[],"version":"current","frontMatter":{"sidebar_postion":10},"sidebar":"tutorialSidebar","previous":{"title":"calculate_initial_bearing","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/calculate_initial_bearing"},"next":{"title":"generate_collision_free_paths","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_collision_free_paths"}}');var t=i(4848),r=i(8453);const d={sidebar_postion:10},c="find_conflicting_paths_np",o={},a=[{value:"Function Signature",id:"function-signature",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Returns",id:"returns",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"1. <strong>Create Spatial Buckets by Time Bins</strong>",id:"1-create-spatial-buckets-by-time-bins",level:3},{value:"2. <strong>For Each Time Bin, Find Conflicts Using Spatial KD-Tree</strong>",id:"2-for-each-time-bin-find-conflicts-using-spatial-kd-tree",level:3},{value:"3. <strong>Return Conflicting Drone Indices</strong>",id:"3-return-conflicting-drone-indices",level:3},{value:"Example Usage",id:"example-usage",level:2},{value:"Summary",id:"summary",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"find_conflicting_paths_np",children:(0,t.jsx)(n.code,{children:"find_conflicting_paths_np"})})}),"\n",(0,t.jsxs)(n.p,{children:["This function analyzes multiple drone paths (each represented as a NumPy array of positions and times) to find drones that come within a minimum safe distance of each other ",(0,t.jsx)(n.strong,{children:"at the same or near time steps"}),", indicating potential conflicts or collisions."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def find_conflicting_paths_np(np_paths, min_safe_dist=50, time_res=0.2):\n"})}),"\n",(0,t.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Name"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"np_paths"})}),(0,t.jsx)(n.td,{children:"list of np.ndarray"}),(0,t.jsxs)(n.td,{children:["Each element is a NumPy array ",(0,t.jsx)(n.code,{children:"(N,3)"})," with columns ",(0,t.jsx)(n.code,{children:"[x, y, t]"})," representing a drone path in meters and time."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"min_safe_dist"})}),(0,t.jsx)(n.td,{children:"float"}),(0,t.jsx)(n.td,{children:"Minimum safe distance (in meters) between drones to avoid conflict (default: 50 m)."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"time_res"})}),(0,t.jsx)(n.td,{children:"float"}),(0,t.jsx)(n.td,{children:"Time resolution in seconds to bin time steps together (default: 0.2 s)."})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"conflicting_indices"}),": A set of integers indicating indices of drones whose paths conflict by violating the minimum safe distance at any binned time step."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsxs)(n.h3,{id:"1-create-spatial-buckets-by-time-bins",children:["1. ",(0,t.jsx)(n.strong,{children:"Create Spatial Buckets by Time Bins"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"spatial_buckets = defaultdict(list)\nconflicting_indices = set()\n\nfor drone_idx, arr in enumerate(np_paths):\n    times = arr[:, 2]\n    time_bins = np.round(times / time_res).astype(int)\n    for point_idx, tb in enumerate(time_bins):\n        spatial_buckets[tb].append((drone_idx, point_idx))\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each drone's path has points with timestamps."}),"\n",(0,t.jsxs)(n.li,{children:["Times are grouped into discrete bins (",(0,t.jsx)(n.code,{children:"time_bins"}),") by dividing by ",(0,t.jsx)(n.code,{children:"time_res"})," and rounding."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"spatial_buckets"})," maps each time bin to a list of ",(0,t.jsx)(n.code,{children:"(drone_idx, point_idx)"})," pairs indicating which drone points exist in that time bin."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This groups points that occur at approximately the same time together."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"2-for-each-time-bin-find-conflicts-using-spatial-kd-tree",children:["2. ",(0,t.jsx)(n.strong,{children:"For Each Time Bin, Find Conflicts Using Spatial KD-Tree"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"for tb, entries in spatial_buckets.items():\n    if len(entries) < 2:\n        continue\n    points = []\n    drones = []\n    for drone_idx, point_idx in entries:\n        x, y = np_paths[drone_idx][point_idx, :2]\n        points.append([x, y])\n        drones.append(drone_idx)\n    points = np.array(points)\n    tree = cKDTree(points)\n    pairs = tree.query_pairs(r=min_safe_dist)\n    for i, j in pairs:\n        conflicting_indices.add(drones[i])\n        conflicting_indices.add(drones[j])\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"For each time bin with at least two drone points:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Extract their ",(0,t.jsx)(n.code,{children:"(x, y)"})," coordinates into an array."]}),"\n",(0,t.jsxs)(n.li,{children:["Build a ",(0,t.jsx)(n.strong,{children:"KD-tree"})," (",(0,t.jsx)(n.code,{children:"cKDTree"}),") for efficient spatial queries."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"query_pairs"})," to find all pairs of points closer than ",(0,t.jsx)(n.code,{children:"min_safe_dist"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["For each pair found, add the drone indices to the ",(0,t.jsx)(n.code,{children:"conflicting_indices"})," set."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This efficiently detects spatial proximity conflicts among drones flying roughly simultaneously."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"3-return-conflicting-drone-indices",children:["3. ",(0,t.jsx)(n.strong,{children:"Return Conflicting Drone Indices"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"return conflicting_indices\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The function returns a set of unique drone indices involved in any conflict."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'conflicts = find_conflicting_paths_np(np_paths, min_safe_dist=50, time_res=0.2)\nprint("Conflicting drone indices:", conflicts)\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Time binning"}),(0,t.jsx)(n.td,{children:"Groups drone positions by approximate time steps to compare simultaneous points"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"KD-tree search"}),(0,t.jsx)(n.td,{children:"Fast spatial proximity search among drone points within each time bin"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Conflict detection"}),(0,t.jsx)(n.td,{children:"Finds drones whose positions violate minimum safe distance during flight"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Output"}),(0,t.jsx)(n.td,{children:"Returns indices of drones involved in potential conflicts"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>c});var s=i(6540);const t={},r=s.createContext(t);function d(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);