"use strict";(self.webpackChunkdeploy_to_vm=self.webpackChunkdeploy_to_vm||[]).push([[6259],{1451:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"Repositories/PRISM/FastAPI/Helper Functions/generate_rogue_path","title":"generate_rogue_path","description":"This function modifies a portion of an existing drone path, introducing a controlled detour (\u201crogue\u201d segment) before rejoining the original route.","source":"@site/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_rogue_path.md","sourceDirName":"Repositories/PRISM/FastAPI/Helper Functions","slug":"/Repositories/PRISM/FastAPI/Helper Functions/generate_rogue_path","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_rogue_path","draft":false,"unlisted":false,"editUrl":"https://github.com/ryyanrashid01/devdocs/edit/main/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_rogue_path.md","tags":[],"version":"current","frontMatter":{"sidebar_postion":8},"sidebar":"tutorialSidebar","previous":{"title":"generate_collision_free_paths","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_collision_free_paths"},"next":{"title":"generate_single_path","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_single_path"}}');var r=i(4848),s=i(8453);const o={sidebar_postion:8},d="generate_rogue_path",l={},a=[{value:"Function Signature",id:"function-signature",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Overview of Process",id:"overview-of-process",level:2},{value:"1. Define Start and End Indices of Rogue Segment",id:"1-define-start-and-end-indices-of-rogue-segment",level:3},{value:"2. Initialize Position, Time, Speed",id:"2-initialize-position-time-speed",level:3},{value:"3. Copy Original Path Before Rogue Segment",id:"3-copy-original-path-before-rogue-segment",level:3},{value:"4. Build Flight Corridor Polygon and Choose Waypoint Based on Deviation",id:"4-build-flight-corridor-polygon-and-choose-waypoint-based-on-deviation",level:3},{value:"5. Rogue Path Generation Loop",id:"5-rogue-path-generation-loop",level:3},{value:"6. Rejoin Original Path Tail",id:"6-rejoin-original-path-tail",level:3},{value:"Return Value",id:"return-value",level:2},{value:"Summary Table",id:"summary-table",level:2},{value:"Use Case",id:"use-case",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"generate_rogue_path",children:(0,r.jsx)(n.code,{children:"generate_rogue_path"})})}),"\n",(0,r.jsx)(n.p,{children:"This function modifies a portion of an existing drone path, introducing a controlled detour (\u201crogue\u201d segment) before rejoining the original route."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def generate_rogue_path(orig_path, orig_speeds, mz_radius, center, curviness, deviation, dt=0.2, start_frac=0.33, end_frac=0.66):\n"})}),"\n",(0,r.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"orig_path"})}),(0,r.jsx)(n.td,{children:"List of tuples"}),(0,r.jsxs)(n.td,{children:["Original drone path points: ",(0,r.jsx)(n.code,{children:"[((lat, lon), t, speed), ...]"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"orig_speeds"})}),(0,r.jsx)(n.td,{children:"List of floats"}),(0,r.jsxs)(n.td,{children:["Speeds corresponding to ",(0,r.jsx)(n.code,{children:"orig_path"})," points."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mz_radius"})}),(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"Radius (meters) of the monitoring zone."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"center"})}),(0,r.jsx)(n.td,{children:"Point"}),(0,r.jsxs)(n.td,{children:["Center of the monitoring zone (with ",(0,r.jsx)(n.code,{children:".latitude"})," and ",(0,r.jsx)(n.code,{children:".longitude"}),")."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"curviness"})}),(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"Controls the path\u2019s winding during rogue segment (0 = straight, 1 = very curvy)."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"deviation"})}),(0,r.jsx)(n.td,{children:"str"}),(0,r.jsxs)(n.td,{children:["One of ",(0,r.jsx)(n.code,{children:'"none"'}),", ",(0,r.jsx)(n.code,{children:'"minor"'}),", or ",(0,r.jsx)(n.code,{children:'"major"'}),"; controls how far the detour deviates from original path corridor."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"dt"})}),(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"Time step interval between points (seconds)."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"start_frac"})}),(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"Fractional index to start rogue segment (e.g., 0.33 = start at 33% into path)."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"end_frac"})}),(0,r.jsx)(n.td,{children:"float"}),(0,r.jsx)(n.td,{children:"Fractional index to end rogue segment."})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"overview-of-process",children:"Overview of Process"}),"\n",(0,r.jsx)(n.h3,{id:"1-define-start-and-end-indices-of-rogue-segment",children:"1. Define Start and End Indices of Rogue Segment"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"start_idx = int(len(orig_path) * start_frac)\nend_idx = int(len(orig_path) * end_frac)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Rogue segment lies between these indices on the original path."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"2-initialize-position-time-speed",children:"2. Initialize Position, Time, Speed"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"pos = Point(*orig_path[start_idx][0])\nt = orig_path[start_idx][1]\nspeed_at_start = orig_path[start_idx][2]\nspeedSmoother = SmoothSpeed(speed_at_start)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Starts rogue path from the selected start index position and time."}),"\n",(0,r.jsxs)(n.li,{children:["Uses ",(0,r.jsx)(n.code,{children:"SmoothSpeed"})," to generate realistic speed fluctuations."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"3-copy-original-path-before-rogue-segment",children:"3. Copy Original Path Before Rogue Segment"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"rogue_path = list(orig_path[:start_idx])\nrogue_speeds = list(orig_speeds[:start_idx])\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Preserve the initial part of the original path unchanged."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"4-build-flight-corridor-polygon-and-choose-waypoint-based-on-deviation",children:"4. Build Flight Corridor Polygon and Choose Waypoint Based on Deviation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"path_segment = orig_path[start_idx:end_idx]\ncorridor_polygon = build_corridor_polygon(path_segment, buffer_radius_m=20)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Creates a 20-meter buffer polygon corridor around the rogue segment."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Waypoint selection:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"none"'}),": Random point within full monitoring zone."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"minor"'}),": Point inside corridor polygon."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"major"'}),": Point outside corridor polygon."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'if deviation == "none":\n    waypoint_pos = distance(meters=np.random.uniform(0.0, 1.0) * mz_radius).destination(center, np.random.uniform(0, 360))\nelif deviation == "minor":\n    waypoint_pos = sample_point_within_polygon(corridor_polygon, center, mz_radius)\nelse:\n    waypoint_pos = sample_point_outside_polygon(corridor_polygon, center, mz_radius)\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"5-rogue-path-generation-loop",children:"5. Rogue Path Generation Loop"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"while True:\n    t += dt\n    ...\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The drone flies toward the ",(0,r.jsx)(n.code,{children:"waypoint_pos"})," first (",(0,r.jsx)(n.code,{children:"diverting = True"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["After reaching the waypoint (within 10m), it rejoins the original path\u2019s tail (",(0,r.jsx)(n.code,{children:"diverting = False"}),")."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Key steps inside the loop:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Calculate direction vector to target."}),"\n",(0,r.jsx)(n.li,{children:"Blend direction smoothly using a weighted average controlled by distance and curviness."}),"\n",(0,r.jsxs)(n.li,{children:["Add random turning noise proportional to ",(0,r.jsx)(n.code,{children:"curviness"})," when inside the monitoring zone."]}),"\n",(0,r.jsxs)(n.li,{children:["Adjust speed smoothly using ",(0,r.jsx)(n.code,{children:"SmoothSpeed"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Compute next position using geodesic step."}),"\n",(0,r.jsxs)(n.li,{children:["Append the position, time, and speed to ",(0,r.jsx)(n.code,{children:"rogue_path"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"6-rejoin-original-path-tail",children:"6. Rejoin Original Path Tail"}),"\n",(0,r.jsx)(n.p,{children:"After the rogue segment:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Find closest tail point in the original path."}),"\n",(0,r.jsx)(n.li,{children:"Adjust the timestamps of the remaining original path points to follow seamlessly after the rogue path."}),"\n",(0,r.jsxs)(n.li,{children:["Append adjusted tail to ",(0,r.jsx)(n.code,{children:"rogue_path"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"t_rogue_end = rogue_path[-1][1]\nt_orig_end = orig_path[new_end_idx][1]\ntime_offset = t_rogue_end - t_orig_end\nadjusted_tail = [((lat, lon), t + time_offset, s) for (lat, lon), t, s in orig_path[new_end_idx:]]\nrogue_path.extend(adjusted_tail)\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"return-value",children:"Return Value"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Returns ",(0,r.jsx)(n.code,{children:"rogue_path"}),": the full drone path including the rogue detour and adjusted tail segment."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary-table",children:"Summary Table"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Step"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Initialize rogue segment start"}),(0,r.jsx)(n.td,{children:"Pick start/end points and initialize position, time, speed"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Select waypoint"}),(0,r.jsx)(n.td,{children:"Based on deviation type, select where drone diverts"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Fly toward waypoint"}),(0,r.jsx)(n.td,{children:"Use direction blending and noise to simulate curvy detour"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Rejoin original path"}),(0,r.jsx)(n.td,{children:"After waypoint reached, smoothly transition back to original path"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Return new full path"}),(0,r.jsx)(n.td,{children:"Rogue path combined with original tail"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"use-case",children:"Use Case"}),"\n",(0,r.jsx)(n.p,{children:"You can use this function to simulate drones deviating unpredictably within their monitoring zone while maintaining realistic flight dynamics and timing."})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>d});var t=i(6540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);