"use strict";(self.webpackChunkdeploy_to_vm=self.webpackChunkdeploy_to_vm||[]).push([[4132],{8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(6540);const a={},r=t.createContext(a);function s(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(r.Provider,{value:n},e.children)}},9601:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Repositories/PRISM/FastAPI/Helper Functions/calculate_initial_bearing","title":"calculate_initial_bearing","description":"This function calculates the initial compass bearing (in degrees) from a starting geographic coordinate to a target geographic coordinate. It\u2019s particularly useful in navigation, drone path planning, and geospatial analysis.","source":"@site/docs/Repositories/PRISM/FastAPI/Helper Functions/calculate_initial_bearing.md","sourceDirName":"Repositories/PRISM/FastAPI/Helper Functions","slug":"/Repositories/PRISM/FastAPI/Helper Functions/calculate_initial_bearing","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/calculate_initial_bearing","draft":false,"unlisted":false,"editUrl":"https://github.com/ryyanrashid01/devdocs/edit/main/docs/Repositories/PRISM/FastAPI/Helper Functions/calculate_initial_bearing.md","tags":[],"version":"current","frontMatter":{"sidebar_postion":1},"sidebar":"tutorialSidebar","previous":{"title":"calculate_direction","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/calculate_direction"},"next":{"title":"find_conflicting_paths_np","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/find_conflicting_paths"}}');var a=i(4848),r=i(8453);const s={sidebar_postion:1},l="calculate_initial_bearing",o={},c=[{value:"Function Definition",id:"function-definition",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Returns",id:"returns",level:3},{value:"Example Use Case",id:"example-use-case",level:2},{value:"Internal Logic Explained",id:"internal-logic-explained",level:2},{value:"Convert Degrees to Radians",id:"convert-degrees-to-radians",level:3},{value:"Calculate Components",id:"calculate-components",level:3},{value:"Bearing Calculation",id:"bearing-calculation",level:3},{value:"Convert to Degrees and Normalize",id:"convert-to-degrees-and-normalize",level:3},{value:"Output Interpretation",id:"output-interpretation",level:2},{value:"Notes",id:"notes",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"calculate_initial_bearing",children:(0,a.jsx)(n.code,{children:"calculate_initial_bearing"})})}),"\n",(0,a.jsxs)(n.p,{children:["This function calculates the ",(0,a.jsx)(n.strong,{children:"initial compass bearing"})," (in degrees) from a starting geographic coordinate to a target geographic coordinate. It\u2019s particularly useful in navigation, drone path planning, and geospatial analysis."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"function-definition",children:"Function Definition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def calculate_initial_bearing(start, target):\n"})}),"\n",(0,a.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"start"}),": An Point object with ",(0,a.jsx)(n.code,{children:"latitude"})," and ",(0,a.jsx)(n.code,{children:"longitude"})," attributes (in decimal degrees)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"target"}),": Another Point object with ",(0,a.jsx)(n.code,{children:"latitude"})," and ",(0,a.jsx)(n.code,{children:"longitude"})," attributes."]}),"\n"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"This comes from:"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from geopy.point import Point\n"})}),"\n",(0,a.jsx)(n.h3,{id:"returns",children:"Returns"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"float"}),": The ",(0,a.jsx)(n.strong,{children:"initial bearing"})," from the ",(0,a.jsx)(n.code,{children:"start"})," point to the ",(0,a.jsx)(n.code,{children:"target"})," point, in ",(0,a.jsx)(n.strong,{children:"degrees"}),", ranging from ",(0,a.jsx)(n.code,{children:"0"})," to ",(0,a.jsx)(n.code,{children:"< 360"}),"."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"example-use-case",children:"Example Use Case"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from types import SimpleNamespace\n\nstart = SimpleNamespace(latitude=25.276987, longitude=55.296249)  # Dubai\ntarget = SimpleNamespace(latitude=24.713552, longitude=46.675296)  # Riyadh\n\nbearing = calculate_initial_bearing(start, target)\nprint(f"Initial bearing from Dubai to Riyadh: {bearing:.2f}\xb0")\n'})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"internal-logic-explained",children:"Internal Logic Explained"}),"\n",(0,a.jsx)(n.h3,{id:"convert-degrees-to-radians",children:"Convert Degrees to Radians"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"lat1 = np.radians(start.latitude)\nlat2 = np.radians(target.latitude)\ndelta_lon = np.radians(target.longitude - start.longitude)\n"})}),"\n",(0,a.jsx)(n.p,{children:"All trigonometric calculations are done in radians, so inputs are converted."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"calculate-components",children:"Calculate Components"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"x = np.sin(delta_lon) * np.cos(lat2)\ny = np.cos(lat1) * np.sin(lat2) - np.sin(lat1) * np.cos(lat2) * np.cos(delta_lon)\n"})}),"\n",(0,a.jsx)(n.p,{children:"This computes the Cartesian components of the great-circle bearing."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"bearing-calculation",children:"Bearing Calculation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"initial_bearing = np.arctan2(x, y)\n"})}),"\n",(0,a.jsx)(n.p,{children:"This returns the angle in radians between the meridian and the direction to the target."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"convert-to-degrees-and-normalize",children:"Convert to Degrees and Normalize"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"return np.degrees(initial_bearing) % 360\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Converts radians to degrees."}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"% 360"})," ensures the result is in the ",(0,a.jsx)(n.code,{children:"[0, 360)"})," degree range."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"output-interpretation",children:"Output Interpretation"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"0\xb0"})," = North"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"90\xb0"})," = East"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"180\xb0"})," = South"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"270\xb0"})," = West"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["For example, a result of ",(0,a.jsx)(n.code,{children:"121.5\xb0"})," indicates the initial direction is southeast-ish."]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["This function assumes a spherical Earth model (great-circle path). It does ",(0,a.jsx)(n.strong,{children:"not"})," account for elevation or Earth\u2019s ellipsoid shape."]}),"\n",(0,a.jsx)(n.li,{children:"It is useful when simulating the heading of a drone or vehicle moving from point A to point B."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);