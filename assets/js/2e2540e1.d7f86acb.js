"use strict";(self.webpackChunkdeploy_to_vm=self.webpackChunkdeploy_to_vm||[]).push([[3241],{1456:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Repositories/PRISM/FastAPI/Helper Functions/generate_collision_free_paths","title":"generate_collision_free_paths","description":"This function generates collision-free flight paths for multiple drones within a monitoring zone by repeatedly generating paths and checking for conflicts, then resolving conflicts by regenerating paths as needed.","source":"@site/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_collision_free_paths.md","sourceDirName":"Repositories/PRISM/FastAPI/Helper Functions","slug":"/Repositories/PRISM/FastAPI/Helper Functions/generate_collision_free_paths","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_collision_free_paths","draft":false,"unlisted":false,"editUrl":"https://github.com/ryyanrashid01/devdocs/edit/main/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_collision_free_paths.md","tags":[],"version":"current","frontMatter":{"sidebar_postion":11},"sidebar":"tutorialSidebar","previous":{"title":"find_conflicting_paths_np","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/find_conflicting_paths"},"next":{"title":"generate_rogue_path","permalink":"/devdocs/docs/Repositories/PRISM/FastAPI/Helper Functions/generate_rogue_path"}}');var r=t(4848),i=t(8453);const o={sidebar_postion:11},l="generate_collision_free_paths",a={},d=[{value:"Function Signature",id:"function-signature",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Returns",id:"returns",level:2},{value:"Workflow Overview",id:"workflow-overview",level:2},{value:"1. <strong>Preparation</strong>",id:"1-preparation",level:3},{value:"2. <strong>Initial Path Generation (Parallelized)</strong>",id:"2-initial-path-generation-parallelized",level:3},{value:"3. <strong>Convert Paths to NumPy for Collision Detection</strong>",id:"3-convert-paths-to-numpy-for-collision-detection",level:3},{value:"4. <strong>Collision Detection and Resolution Loop</strong>",id:"4-collision-detection-and-resolution-loop",level:3},{value:"5. <strong>Final Formatting of Paths</strong>",id:"5-final-formatting-of-paths",level:3},{value:"Summary Table",id:"summary-table",level:2},{value:"Example Usage",id:"example-usage",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"generate_collision_free_paths",children:(0,r.jsx)(n.code,{children:"generate_collision_free_paths"})})}),"\n",(0,r.jsx)(n.p,{children:"This function generates collision-free flight paths for multiple drones within a monitoring zone by repeatedly generating paths and checking for conflicts, then resolving conflicts by regenerating paths as needed."}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"function-signature",children:"Function Signature"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def generate_collision_free_paths(center, mz_radius, drones):\n"})}),"\n",(0,r.jsx)(n.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Name"}),(0,r.jsx)(n.th,{children:"Type"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"center"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"Point"})}),(0,r.jsx)(n.td,{children:"Center of the monitoring zone (latitude, longitude)."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"mz_radius"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"float"})}),(0,r.jsx)(n.td,{children:"Radius of the monitoring zone in meters."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"drones"})}),(0,r.jsxs)(n.td,{children:["List of ",(0,r.jsx)(n.code,{children:"DroneConfig"})]}),(0,r.jsx)(n.td,{children:"List of drone configurations including speed and tortuosity."})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"returns",children:"Returns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A list of collision-free paths, where each path is a list of dictionaries containing ",(0,r.jsx)(n.code,{children:"lat"}),", ",(0,r.jsx)(n.code,{children:"lon"}),", ",(0,r.jsx)(n.code,{children:"t"})," (time), and ",(0,r.jsx)(n.code,{children:"speed"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"workflow-overview",children:"Workflow Overview"}),"\n",(0,r.jsxs)(n.h3,{id:"1-preparation",children:["1. ",(0,r.jsx)(n.strong,{children:"Preparation"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"num_drones = len(drones)\nargs = [(center, mz_radius, drone.tortuosity, drone.speed) for drone in drones]\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prepares arguments for generating each drone\u2019s path based on its configuration."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h3,{id:"2-initial-path-generation-parallelized",children:["2. ",(0,r.jsx)(n.strong,{children:"Initial Path Generation (Parallelized)"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"with ProcessPoolExecutor(max_workers=os.cpu_count()) as executor:\n    paths = list(executor.map(generate_single_path_wrapper, args))\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Uses Python\u2019s ",(0,r.jsx)(n.code,{children:"ProcessPoolExecutor"})," to generate each drone path in parallel to speed up computation."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"generate_single_path_wrapper"})," is a helper to seed randomness uniquely per process."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h3,{id:"3-convert-paths-to-numpy-for-collision-detection",children:["3. ",(0,r.jsx)(n.strong,{children:"Convert Paths to NumPy for Collision Detection"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"center_lat, center_lon = center.latitude, center.longitude\nnp_paths = paths_to_numpy(paths, center_lat, center_lon)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Converts generated paths to NumPy arrays (x, y, t) relative to the monitoring zone center."}),"\n",(0,r.jsx)(n.li,{children:"Facilitates efficient spatial and temporal collision checks."}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h3,{id:"4-collision-detection-and-resolution-loop",children:["4. ",(0,r.jsx)(n.strong,{children:"Collision Detection and Resolution Loop"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'attempts = 0\nwhile True:\n    if attempts > 1000:\n        print("[ERROR] : Too many attempts to resolve conflicts. Exiting.")\n        return []\n\n    bad = find_conflicting_paths_np(np_paths)\n    attempts += 1\n\n    if bad:\n        print(f"[CONFLICT] : [Pass-{attempts}] - Conflict between paths {bad}")\n    else:\n        print("[CONFLICT] : Conflicts resolved.")\n        break\n\n    new_args = [(center, mz_radius, drones[idx].tortuosity, drones[idx].speed) for idx in bad]\n    with ProcessPoolExecutor(max_workers=os.cpu_count()) as executor:\n        new_paths = list(executor.map(generate_single_path_wrapper, new_args))\n\n    for idx, new_path in zip(bad, new_paths):\n        paths[idx] = new_path\n        np_paths[idx] = paths_to_numpy([new_path], center_lat, center_lon)[0]\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Repeatedly checks for path conflicts."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"If conflicts exist:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prints conflicting drone indices."}),"\n",(0,r.jsx)(n.li,{children:"Regenerates only the conflicting drones' paths in parallel."}),"\n",(0,r.jsx)(n.li,{children:"Updates those paths and their NumPy representations."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Stops when no conflicts remain or if it exceeds 1000 attempts to avoid infinite loops."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h3,{id:"5-final-formatting-of-paths",children:["5. ",(0,r.jsx)(n.strong,{children:"Final Formatting of Paths"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'formatted_paths = [\n    [\n        {"lat": lat, "lon": lon, "t": t, "speed": s}\n        for ((lat, lon), t, s) in path_data\n    ]\n    for (path_data, _) in paths\n]\nreturn formatted_paths\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Converts each path from internal tuple format ",(0,r.jsx)(n.code,{children:"((lat, lon), t, speed)"})," into a list of dictionaries expected by the frontend or API clients."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"summary-table",children:"Summary Table"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Step"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Prepare arguments"}),(0,r.jsx)(n.td,{children:"Extract parameters from drone configs"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Generate paths"}),(0,r.jsx)(n.td,{children:"Parallel generation of initial drone paths"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Convert to NumPy"}),(0,r.jsx)(n.td,{children:"For efficient conflict detection"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Conflict detection loop"}),(0,r.jsx)(n.td,{children:"Check & fix conflicts by regenerating paths"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Format output"}),(0,r.jsx)(n.td,{children:"Convert path data to frontend-friendly dicts"})]})]})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'paths = generate_collision_free_paths(center, mz_radius, drones)\nprint(f"Generated {len(paths)} collision-free paths.")\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);